"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7844],{20036:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});let r=JSON.parse('{"id":"javelin-core/route-configuration","title":"Route Configuration","description":"Comprehensive guide to configuring Javelin routes including models, providers, rate limits, and advanced settings","source":"@site/docs/javelin-core/routeconfiguration.md","sourceDirName":"javelin-core","slug":"/javelin-core/route-configuration","permalink":"/javelin-core/route-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/getjavelin/documentation/tree/main/docs/javelin-core/routeconfiguration.md","tags":[],"version":"current","frontMatter":{"id":"route-configuration","title":"Route Configuration","description":"Comprehensive guide to configuring Javelin routes including models, providers, rate limits, and advanced settings","sidebar_label":"Route Configuration"},"sidebar":"docsSidebar","previous":{"title":"Integration Overview","permalink":"/javelin-core/gatewayconfiguration"},"next":{"title":"Provider Configuration","permalink":"/javelin-core/providerconfiguration"}}');var n=i(74848),o=i(28453);i(74235),i(15947);var s=i(78667);let a={id:"route-configuration",title:"Route Configuration",description:"Comprehensive guide to configuring Javelin routes including models, providers, rate limits, and advanced settings",sidebar_label:"Route Configuration"},l="Route Configuration",c={},d=[{value:"Route Fields",id:"route-fields",level:2},{value:"Model",id:"model",level:3},{value:"Config",id:"config",level:3}];function u(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"route-configuration",children:"Route Configuration"})}),"\n",(0,n.jsx)(t.p,{children:"Routes are the core component of Javelin that define how incoming requests are processed, which models they connect to, and what policies are applied. This comprehensive guide covers all route configuration options including models, providers, rate limits, cost guardrails, security policies, and advanced traffic shaping. You'll learn to configure sophisticated routing logic that balances performance, cost, and security for your AI applications."}),"\n","\n",(0,n.jsx)(t.h1,{id:"route-object",children:"Route Object"}),"\n",(0,n.jsx)(t.p,{children:"When represented as json, the route object has the following structure:"}),"\n",(0,n.jsx)(s.A,{language:"python",children:`{
    "name": "name of the route",
    "type": "this could be \`chat\`, \`completions\`, \`embeddings\` etc.,",
    "models": [ 
      {
        "name": "name of the model to use, like text-davinci-003",
        "provider": "name of the llm provider - openai",
        "suffix": "/chat/completions"
      } 
    ],
    "config": {
      "rate_limit": 3,
      "archive": true,
      "retries": 3
    }
  }`}),"\n",(0,n.jsx)(t.h2,{id:"route-fields",children:"Route Fields"}),"\n",(0,n.jsxs)(t.p,{children:["These configuration settings are all defined per ",(0,n.jsx)(t.code,{children:"route"}),", they are not global and are applied individually on each route."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"name"})}),(0,n.jsx)(t.td,{children:"This field specifies the unique identifier or name for the route within the gateway. It is used to direct requests to the correct endpoint or service, facilitating organized management and routing of API calls. The name should be descriptive enough to indicate its purpose or the nature of the requests it handles, such as forwarding queries to the LLM for processing."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"type"})}),(0,n.jsx)(t.td,{children:"Indicates the specific functionality of the LLM endpoint that the route targets. The options include:"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsxs)(t.td,{children:["- ",(0,n.jsx)(t.strong,{children:"chat"}),": Routes targeting this type are designed to handle interactive, conversational queries, utilizing the LLM's capabilities to generate responses in a chat-like format. This is typically used for building chatbots or conversational agents."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsxs)(t.td,{children:["- ",(0,n.jsx)(t.strong,{children:"completions"}),": This type is aimed at generating text completions or responses based on prompts provided in the requests. It's suitable for applications requiring content generation, creative writing assistance, code generation, etc."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{}),(0,n.jsxs)(t.td,{children:["- ",(0,n.jsx)(t.strong,{children:"embeddings"}),": Routes of this type are focused on generating numerical representations (embeddings) of the input text, which can be used for tasks such as semantic similarity comparison, clustering, or search applications."]})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"model",children:"Model"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"name"})}),(0,n.jsx)(t.td,{children:"Specifies the identifier or name of the model you intend to use for your application. This name is critical for ensuring that requests are routed to the correct model, particularly when a gateway or service offers access to multiple models. It should match the model name as defined by the LLM provider."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"provider"})}),(0,n.jsxs)(t.td,{children:["Identifies the LLM provider. This field allows you to specify the source of the LLM, such as ",(0,n.jsx)(t.code,{children:"openai"})," for models like GPT-3, ",(0,n.jsx)(t.code,{children:"cohere"}),", ",(0,n.jsx)(t.code,{children:"anthropic"}),", or ",(0,n.jsx)(t.code,{children:"huggingface"}),". Each provider has its own set of models, capabilities, and API structures, so specifying the provider is crucial for correctly interfacing with their service."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"suffix"})}),(0,n.jsx)(t.td,{children:"This field is particularly useful when working with customizable or specific versions of models, especially on platforms like Hugging Face. It allows you to append a custom path or identifier to the model URL endpoint, enabling access to custom or fine-tuned models that may not be directly available through the standard API endpoints. This customization can be crucial for applications requiring highly specialized model behavior or training on specific datasets."})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"config",children:"Config"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"rate_limit"})}),(0,n.jsx)(t.td,{children:"Specifies the maximum number of requests per second (RPS) that can be sent through this route. Setting a rate limit is crucial for preventing overloading the LLM provider's API, which can lead to request denials or additional charges. It ensures that your application stays within the operational limits of the LLM service and maintains a good standing with the provider."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"archive"})}),(0,n.jsx)(t.td,{children:"A boolean setting (true or false) that determines whether interactions (both requests to and responses from) with the LLMs should be archived. Enabling this feature (true) is important for record-keeping, compliance, and analysis purposes. It allows organizations to review historical data for insights, audit interactions for compliance with regulations, or debug issues."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"retries"})}),(0,n.jsx)(t.td,{children:"Indicates the number of retry attempts the gateway will make in the event of receiving a 503 (Service Unavailable) response from the LLM. This is critical for enhancing the reliability of the service, ensuring that temporary issues with the LLM provider do not immediately result in failures for end-users. By automatically retrying, the system can often overcome transient issues without manual intervention."})]})]})]})]})}function h(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},15947:(e,t,i)=>{i.d(t,{A:()=>o});var r=i(74848);i(96540);var n=i(18215);function o({children:e,hidden:t,className:i}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,n.A)("tabItem_Ymn6",i),hidden:t,children:e})}},74235:(e,t,i)=>{i.d(t,{A:()=>j});var r=i(74848),n=i(96540),o=i(18215),s=i(52204),a=i(56347),l=i(13321),c=i(57641),d=i(73094),u=i(57237);function h(e){return n.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){let{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p({value:e,tabValues:t}){return t.some(t=>t.value===e)}var f=i(12075);function m({className:e,block:t,selectedValue:i,selectValue:n,tabValues:a}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{let t=e.currentTarget,r=a[l.indexOf(t)].value;r!==i&&(c(t),n(r))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let i=l.indexOf(e.currentTarget)+1;t=l[i]??l[0];break}case"ArrowLeft":{let i=l.indexOf(e.currentTarget)-1;t=l[i]??l[l.length-1]}}t?.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":t},e),children:a.map(({value:e,label:t,attributes:n})=>(0,r.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{l.push(e)},onKeyDown:u,onClick:d,...n,className:(0,o.A)("tabs__item","tabItem_LNqP",n?.className,{"tabs__item--active":i===e}),children:t??e},e))})}function g({lazy:e,children:t,selectedValue:i}){let s=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){let e=s.find(e=>e.props.value===i);return e?(0,n.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:s.map((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==i}))})}function v(e){let t=function(e){let{defaultValue:t,queryString:i=!1,groupId:r}=e,o=function(e){let{values:t,children:i}=e;return(0,n.useMemo)(()=>{let e=t??h(i).map(({props:{value:e,label:t,attributes:i,default:r}})=>({value:e,label:t,attributes:i,default:r})),r=(0,d.XI)(e,(e,t)=>e.value===t.value);if(r.length>0)throw Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[t,i])}(e),[s,f]=(0,n.useState)(()=>(function({defaultValue:e,tabValues:t}){if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let i=t.find(e=>e.default)??t[0];if(!i)throw Error("Unexpected error: 0 tabValues");return i.value})({defaultValue:t,tabValues:o})),[m,g]=function({queryString:e=!1,groupId:t}){let i=(0,a.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,c.aZ)(r),(0,n.useCallback)(e=>{if(!r)return;let t=new URLSearchParams(i.location.search);t.set(r,e),i.replace({...i.location,search:t.toString()})},[r,i])]}({queryString:i,groupId:r}),[v,j]=function({groupId:e}){let t=e?`docusaurus.tab.${e}`:null,[i,r]=(0,u.Dv)(t);return[i,(0,n.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:r}),x=(()=>{let e=m??v;return p({value:e,tabValues:o})?e:null})();return(0,l.A)(()=>{x&&f(x)},[x]),{selectedValue:s,selectValue:(0,n.useCallback)(e=>{if(!p({value:e,tabValues:o}))throw Error(`Can't select invalid tab value=${e}`);f(e),g(e),j(e)},[g,j,o]),tabValues:o}}(e);return(0,r.jsxs)("div",{className:(0,o.A)("tabs-container","tabList__CuJ"),children:[(0,r.jsx)(m,{...t,...e}),(0,r.jsx)(g,{...t,...e})]})}function j(e){let t=(0,f.A)();return(0,r.jsx)(v,{...e,children:h(e.children)},String(t))}}}]);