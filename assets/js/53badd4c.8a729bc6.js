"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[47],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),f=r,m=d["".concat(c,".").concat(f)]||d[f]||u[f]||o;return t?a.createElement(m,i(i({ref:n},p),{},{components:t})):a.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=f;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},7406:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const o={},i="Load Balancing",l={unversionedId:"javelin-core/loadbalancing",id:"javelin-core/loadbalancing",title:"Load Balancing",description:"Organizations have several use cases that drive their load balancing needs.",source:"@site/docs/javelin-core/loadbalancing.md",sourceDirName:"javelin-core",slug:"/javelin-core/loadbalancing",permalink:"/docs/javelin-core/loadbalancing",draft:!1,editUrl:"https://github.com/getjavelin/documentation/tree/main/docs/javelin-core/loadbalancing.md",tags:[],version:"current",frontMatter:{},sidebar:"someSidebar",previous:{title:"Rate Limits",permalink:"/docs/javelin-core/ratelimits"},next:{title:"Semantic Caching",permalink:"/docs/javelin-core/caching"}},c={},s=[{value:"Use Cases",id:"use-cases",level:2},{value:"Traffic Load Shaping",id:"traffic-load-shaping",level:3},{value:"LLM Fallback",id:"llm-fallback",level:3},{value:"Credential Harvesting",id:"credential-harvesting",level:3}],p={toc:s},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"load-balancing"},"Load Balancing"),(0,r.kt)("p",null,"Organizations have several use cases that drive their load balancing needs. "),(0,r.kt)("h2",{id:"use-cases"},"Use Cases"),(0,r.kt)("h3",{id:"traffic-load-shaping"},"Traffic Load Shaping"),(0,r.kt)("p",null,"Organizations may want to strike a balance between inference accuracy, cost and latency by setting up a load shaping mix that shapes traffic towards multiple LLMs. "),(0,r.kt)("p",null,"For instance, an example traffic shape could be setup for using OpenAI GPT3.5 Turbo for 70% of the traffic and OpenAI GPT4 for 30% of the traffic. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Setup a Route with load shaping enabled")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\nfrom javelin_sdk import (\n    JavelinClient,\n    Route\n)\n\nroute_data = {\n    "routes": [\n        {\n            "name": "eng_dept",\n            "type": "chat",\n            "models": [\n                {\n                    "model": {\n                        "name": "gpt-4-32k",\n                        "provider": "openai",\n                        "suffix": "/chat/completions",\n                        "weight": 0.7,\n                        "config": {\n                            "rate_limit": 7\n                        }\n                    }\n                },\n                {\n                    "model": {\n                        "name": "gpt-4-32k",\n                        "provider": "openai",\n                        "suffix": "/chat/completions",\n                        "weight": 0.3,\n                        "config": {\n                            "rate_limit": 7\n                        }\n                    }\n                }\n            ]\n        }\n    ]\n}\n\n\nroute = Route.parse_obj(route_data)\n\n# create the route, enable load balancing with weights\n# load shaping can be configured to take effect across models within a provider or across providers\ntry:\n    await client.acreate_route(route)\nexcept NetworkError as e:\n    print("Failed to create route: Network Error")\n\n')),(0,r.kt)("h3",{id:"llm-fallback"},"LLM Fallback"),(0,r.kt)("p",null,"One way to manage inference costs is to setup LLM fallbacks when specific routes have exhausted their budgets. "),(0,r.kt)("p",null,"For instance, the route may be defined to use OpenAI GPT3.5 Turbo with a Google BARD fallback when the cost or policy budgets are exceeded. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Setup a Route with fallback enabled")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\nfrom javelin_sdk import (\n    JavelinClient,\n    Route\n)\n\nroute_data = {\n    "routes": [\n        {\n            "name": "eng_dept",\n            "type": "chat",\n            "models": [\n                {\n                    "model": {\n                        "name": "gpt-3.5-turbo",\n                        "provider": "openai",\n                        "suffix": "/chat/completions",\n                        "config": {\n                            "rate_limit": 5\n                        }\n                    }\n                },\n                {\n                    "model": {\n                        "name": "chat-bison-001",\n                        "provider": "googlebard",\n                        "suffix": "/v1beta2/models/chat-bison-001",\n                        "fallback":true,\n                        "config": {\n                            "rate_limit": 10\n                        }\n                    }\n                }\n            ]\n        }\n    ]\n}\n\n\nroute = Route.parse_obj(route_data)\n\n# create the route, enable load balancing with weights\n# load shaping can be configured to take effect across models within a provider or across providers\ntry:\n    await client.acreate_route(route)\nexcept NetworkError as e:\n    print("Failed to create route: Network Error")\n\n')),(0,r.kt)("h3",{id:"credential-harvesting"},"Credential Harvesting"),(0,r.kt)("p",null,"Many model providers enforce rate limiting on each of their credentials provisioned. As Application inference needs continually expand, they find that it may be beneficial to spread their load evenly across multiple credentials (or keys). "),(0,r.kt)("p",null,"For instance, the Application may choose to spread an anticipated load of 100 queries/second across 10 credential keys each with 10 queries/sec towards a specific model."))}u.isMDXComponent=!0}}]);