"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9617],{5680:(e,t,r)=>{r.d(t,{xA:()=>c,yg:()=>g});var n=r(6540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(r),y=a,g=d["".concat(s,".").concat(y)]||d[y]||p[y]||i;return r?n.createElement(g,o(o({ref:t},c),{},{components:r})):n.createElement(g,o({ref:t},c))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=y;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}y.displayName="MDXCreateElement"},9365:(e,t,r)=>{r.d(t,{A:()=>o});var n=r(6540),a=r(53);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:r,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,a.A)(i.tabItem,o),hidden:r},t)}},1470:(e,t,r)=>{r.d(t,{A:()=>k});var n=r(8168),a=r(6540),i=r(53),o=r(3104),l=r(6347),s=r(7485),u=r(1682),c=r(9466);function d(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:n,default:a}}=e;return{value:t,label:r,attributes:n,default:a}}))}function p(e){const{values:t,children:r}=e;return(0,a.useMemo)((()=>{const e=t??d(r);return function(e){const t=(0,u.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function y(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:r}=e;const n=(0,l.W6)(),i=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,s.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function m(e){const{defaultValue:t,queryString:r=!1,groupId:n}=e,i=p(e),[o,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!y({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=r.find((e=>e.default))??r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[s,u]=g({queryString:r,groupId:n}),[d,m]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,c.Dv)(r);return[n,(0,a.useCallback)((e=>{r&&i.set(e)}),[r,i])]}({groupId:n}),f=(()=>{const e=s??d;return y({value:e,tabValues:i})?e:null})();(0,a.useLayoutEffect)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!y({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),m(e)}),[u,m,i]),tabValues:i}}var f=r(2303);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:r,selectedValue:l,selectValue:s,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),p=e=>{const t=e.currentTarget,r=c.indexOf(t),n=u[r].value;n!==l&&(d(t),s(n))},y=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const r=c.indexOf(e.currentTarget)+1;t=c[r]??c[0];break}case"ArrowLeft":{const r=c.indexOf(e.currentTarget)-1;t=c[r]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":r},t)},u.map((e=>{let{value:t,label:r,attributes:o}=e;return a.createElement("li",(0,n.A)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:y,onClick:p},o,{className:(0,i.A)("tabs__item",h.tabItem,o?.className,{"tabs__item--active":l===t})}),r??t)})))}function v(e){let{lazy:t,children:r,selectedValue:n}=e;const i=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===n));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function N(e){const t=m(e);return a.createElement("div",{className:(0,i.A)("tabs-container",h.tabList)},a.createElement(b,(0,n.A)({},e,t)),a.createElement(v,(0,n.A)({},e,t)))}function k(e){const t=(0,f.A)();return a.createElement(N,(0,n.A)({key:String(t)},e))}},5725:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=r(8168),a=(r(6540),r(5680));r(1470),r(9365);const i={},o="Integration Overview",l={unversionedId:"javelin-core/secretsconfiguration",id:"javelin-core/secretsconfiguration",title:"Integration Overview",description:"Javelin offers configuration options to setup Large Language Models(LLMs) API Keys. You can easily setup virtual keys for all the providers. This will enable all your applications across your enterprise access all of your providers with just Javelin API Key.",source:"@site/docs/javelin-core/secretsconfiguration.md",sourceDirName:"javelin-core",slug:"/javelin-core/secretsconfiguration",permalink:"/docs/javelin-core/secretsconfiguration",draft:!1,editUrl:"https://github.com/getjavelin/documentation/tree/main/docs/javelin-core/secretsconfiguration.md",tags:[],version:"current",frontMatter:{},sidebar:"someSidebar",previous:{title:"Deleting Template",permalink:"/docs/javelin-core/administration/deletetemplate"},next:{title:"Creating Virtual Key",permalink:"/docs/javelin-core/administration/createvkey"}},s={},u=[{value:"Secret Fields",id:"secret-fields",level:2}],c={toc:u},d="wrapper";function p(e){let{components:t,...r}=e;return(0,a.yg)(d,(0,n.A)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"integration-overview"},"Integration Overview"),(0,a.yg)("p",null,"Javelin offers configuration options to setup Large Language Models(LLMs) API Keys. You can easily setup virtual keys for all the providers. This will enable all your applications across your enterprise access all of your providers with just Javelin API Key."),(0,a.yg)("h1",{id:"secret-object"},"Secret Object"),(0,a.yg)("p",null,"When represented as json, the provider object has the following structure:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},'  {\n    "api_key": "unique key for the secret",\n    "api_key_secret_name": "name for the secret",\n    "api_key_secret_key": "API key from the provider",\n    "api_key_secret_key_javelin": "Virtual API key generated by Javelin service",\n    "provider_name": "openai",\n    "query_param_key": "",\n    "header_key": "",\n    "group": "sales",\n    "enabled": true\n  }\n')),(0,a.yg)("h2",{id:"secret-fields"},"Secret Fields"),(0,a.yg)("p",null,"These configuration settings are all defined per ",(0,a.yg)("inlineCode",{parentName:"p"},"secret"),", they are not global and are applied individually on each route. "),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Field"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"api_key")),(0,a.yg)("td",{parentName:"tr",align:null},"A unique identifier assigned to the API secret. This key is used to reference the secret within your system or codebase, ensuring that the actual sensitive values are not exposed")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"api_key_secret_name")),(0,a.yg)("td",{parentName:"tr",align:null},"The descriptive name given to the secret. This name helps users and administrators identify the purpose or association of the secret, such as which service or API it is used for")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"api_key_secret_key")),(0,a.yg)("td",{parentName:"tr",align:null},"The actual secret key or token provided by the provider. This is the sensitive piece of information that grants access to the API and should be protected accordingly")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"api_key_secret_key_javelin")),(0,a.yg)("td",{parentName:"tr",align:null},"A virtual API key that represents the original secret within a secure environment like Javelin. This abstraction layer enhances security by minimizing direct exposure of the actual secret key")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"provider_name")),(0,a.yg)("td",{parentName:"tr",align:null},"Identifies the provider or platform to which the secret pertains. This clarifies the context in which the secret is used, aiding in its management and application")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"query_param_key")),(0,a.yg)("td",{parentName:"tr",align:null},"The key name for passing the secret as a query parameter in API requests. This is relevant for APIs that authenticate requests through parameters rather than headers")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"header_key")),(0,a.yg)("td",{parentName:"tr",align:null},"The key name for sending the secret within the request header. Many APIs prefer header-based authentication as it keeps the secret out of the URL")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"group")),(0,a.yg)("td",{parentName:"tr",align:null},"A categorization tool that groups related secrets together. This can be used to organize secrets by team, project, environment, or any other logical grouping, facilitating easier management and access control")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"enabled")),(0,a.yg)("td",{parentName:"tr",align:null},"Indicates whether the secret is currently active and can be used for API access. This boolean field allows for the quick enabling or disabling of secrets without removing their configuration, useful for managing temporary access or rotating keys")))))}p.isMDXComponent=!0}}]);