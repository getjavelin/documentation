"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2271],{5618:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>l});var o=r(4848),s=r(5680);const t={},i="Overview",a={id:"javelin-processors/overview",title:"Overview",description:"Javelin's core foundation is built around the notion of bounded functional units. Each function within the platform is encapsulated into independent processing units, referred to as Processors.",source:"@site/docs/javelin-processors/overview.md",sourceDirName:"javelin-processors",slug:"/javelin-processors/overview",permalink:"/docs/javelin-processors/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/getjavelin/documentation/tree/main/docs/javelin-processors/overview.md",tags:[],version:"current",frontMatter:{},sidebar:"someSidebar",previous:{title:"Archiving",permalink:"/docs/javelin-core/features/auditarchive"},next:{title:"Prompt Injection",permalink:"/docs/javelin-processors/promptinjection"}},c={},l=[{value:"Processor Execution Framework",id:"processor-execution-framework",level:2},{value:"Synchronous Execution:",id:"synchronous-execution",level:3},{value:"Asynchronous Execution:",id:"asynchronous-execution",level:3},{value:"Processor Chains",id:"processor-chains",level:2},{value:"Request Chains",id:"request-chains",level:3},{value:"Response Chains",id:"response-chains",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,s.RP)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:["Javelin's core foundation is built around the notion of bounded functional units. Each function within the platform is encapsulated into independent processing units, referred to as ",(0,o.jsx)(n.code,{children:"Processors"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"These processors are chained together to form Directed Acyclic Graphs (DAGs) \u2014 creating structured execution pathways known as processor chains. The structure of these DAGs allows for precise control over the execution flow within the platform, enabling a highly customizable and efficient processing environment."}),"\n",(0,o.jsxs)(n.p,{children:["In Javelin, you can implement Guardrails and build custom extensions and integrations as ",(0,o.jsx)(n.code,{children:"Processors"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"processor-execution-framework",children:"Processor Execution Framework"}),"\n",(0,o.jsx)(n.p,{children:"The processors in Javelin can operate in two distinct modes: asynchronous or synchronous. This operational model is selected during the initialization phase of each processor."}),"\n",(0,o.jsx)(n.h3,{id:"synchronous-execution",children:"Synchronous Execution:"}),"\n",(0,o.jsx)(n.p,{children:"This mode is beneficial for tasks that require immediate processing and feedback. It is often employed for critical operations such as implementing model guardrails, which may involve checking against a trust & safety model or applying content and toxicity filters. While synchronous processing ensures inline execution, care must be used to avoid unnecessary processing overhead in the path of LLM calls. Developers can also configure latency budgets for synchronous processors, ensuring that LLM request processing stays within deterministic pre-established limits."}),"\n",(0,o.jsx)(n.h3,{id:"asynchronous-execution",children:"Asynchronous Execution:"}),"\n",(0,o.jsx)(n.p,{children:"In contrast, asynchronous execution allows tasks to be performed without blocking the system, making it ideal for operations in the background. This mode is typically used for triggering events or notifications to enterprise systems, where immediate response is not critical. For example, a custom processor can be written to send a notification to Slack or trigger an event in a Security dashboard when certain data is exchanged with LLMs. Custom processors trigger webhooks, insert data into Data Warehouses, or trigger enterprise workflows."}),"\n",(0,o.jsx)(n.h2,{id:"processor-chains",children:"Processor Chains"}),"\n",(0,o.jsx)(n.p,{children:"Processor chains are a foundational concept within the Javelin platform, representing a sophisticated mechanism for orchestrating the execution flow for calls."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Processor Chains"})," are essentially sequences of processors \u2014 self-contained modules designed to perform specific functions \u2014 arranged in a DAG structure. This arrangement facilitates complex processing sequences and ensures the execution flow is efficient, logical, and adaptable to various enterprise needs."]}),"\n",(0,o.jsxs)(n.p,{children:["Each ",(0,o.jsx)(n.strong,{children:"processor"})," within the chain can be developed, tested, and deployed independently, enhancing the platform\u2019s flexibility and responsiveness to changing requirements. Processor chains can be dynamically adjusted to handle varying loads, making them well-suited for enterprises with fluctuating processing demands. The ability to run processors asynchronously also contributes to the platform\u2019s overall efficiency, allowing for non-blocking operations and improved resource utilization."]}),"\n",(0,o.jsx)(n.p,{children:"Processors can be attached to one or more routes in Javelin. For example, you can designate a specific Processor Chain to execute while triggering OpenAI calls and a completely different Processor Chain to trigger a Huggingface model."}),"\n",(0,o.jsx)(n.h3,{id:"request-chains",children:"Request Chains"}),"\n",(0,o.jsx)(n.p,{children:"When a request enters the Javelin platform, it can be directed through a specifically designed processor chain configured to analyze, validate, and pre-process the data before it goes to a model. Typical checks here involve filtering or redacting PII/PHI information."}),"\n",(0,o.jsx)(n.h3,{id:"response-chains",children:"Response Chains"}),"\n",(0,o.jsx)(n.p,{children:"Once the LLM responds to the application, the response processor chain is triggered to format, enrich, and securely deliver the response back to the application."})]})}function h(e={}){const{wrapper:n}={...(0,s.RP)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},5680:(e,n,r)=>{r.d(n,{RP:()=>l});var o=r(6540);function s(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function t(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?t(Object(r),!0).forEach((function(n){s(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):t(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function a(e,n){if(null==e)return{};var r,o,s=function(e,n){if(null==e)return{};var r,o,s={},t=Object.keys(e);for(o=0;o<t.length;o++)r=t[o],n.indexOf(r)>=0||(s[r]=e[r]);return s}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(o=0;o<t.length;o++)r=t[o],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=o.createContext({}),l=function(e){var n=o.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var r=e.components,s=e.mdxType,t=e.originalType,c=e.parentName,h=a(e,["components","mdxType","originalType","parentName"]),u=l(r),p=s,f=u["".concat(c,".").concat(p)]||u[p]||d[p]||t;return r?o.createElement(f,i(i({ref:n},h),{},{components:r})):o.createElement(f,i({ref:n},h))}));h.displayName="MDXCreateElement"}}]);