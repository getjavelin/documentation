"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8545],{5503:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"javelin-core/providerconfiguration","title":"Provider Configuration","description":"Providers represent the external AI services and models that power your Javelin routes, including both open source and closed source Large Language Models (LLMs). This guide covers all provider configuration options including API credentials, endpoints, model specifications, and connection settings. You\'ll learn to configure providers for various AI services like OpenAI, Anthropic, local models, and custom endpoints to build a robust multi-provider infrastructure.","source":"@site/docs/javelin-core/providerconfiguration.md","sourceDirName":"javelin-core","slug":"/javelin-core/providerconfiguration","permalink":"/javelin-core/providerconfiguration","draft":false,"unlisted":false,"editUrl":"https://github.com/getjavelin/documentation/tree/main/docs/javelin-core/providerconfiguration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Route Configuration","permalink":"/javelin-core/route-configuration"},"next":{"title":"Processors Overview","permalink":"/javelin-processors/processors-overview"}}');var i=t(74848),s=t(28453),o=(t(22707),t(53632),t(41776));const a={},l="Provider Configuration",c={},d=[{value:"Provider Fields",id:"provider-fields",level:2},{value:"Config",id:"config",level:3}];function u(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"provider-configuration",children:"Provider Configuration"})}),"\n",(0,i.jsx)(r.p,{children:"Providers represent the external AI services and models that power your Javelin routes, including both open source and closed source Large Language Models (LLMs). This guide covers all provider configuration options including API credentials, endpoints, model specifications, and connection settings. You'll learn to configure providers for various AI services like OpenAI, Anthropic, local models, and custom endpoints to build a robust multi-provider infrastructure."}),"\n","\n",(0,i.jsx)(r.h1,{id:"provider-object",children:"Provider Object"}),"\n",(0,i.jsx)(r.p,{children:"When represented as json, the provider object has the following structure:"}),"\n",(0,i.jsx)(o.A,{language:"json",children:'{\n    "name": "name of the provider",\n    "type": "this could be `open`, `closed` etc.,",\n    "config": {\n        "api_base": "https://api.openai.com",\n        "api_type": "",\n        "api_version": "v1"\n    }\n  }'}),"\n",(0,i.jsx)(r.h2,{id:"provider-fields",children:"Provider Fields"}),"\n",(0,i.jsxs)(r.p,{children:["These configuration settings are all defined per ",(0,i.jsx)(r.code,{children:"provider"}),", they are not global and are applied individually on each route."]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Field"}),(0,i.jsx)(r.th,{children:"Description"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"name"})}),(0,i.jsx)(r.td,{children:"Identifies the name of the provider within the gateway's ecosystem. This should be a unique identifier or title that clearly distinguishes the provider from others in the system. The name could reflect the provider's service, company, or functionality, facilitating easy identification and configuration management. It enables administrators and users to quickly reference and access the specific settings or capabilities associated with that provider."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"type"})}),(0,i.jsxs)(r.td,{children:["Indicates the source availability of the provider's models. An open type signifies that the provider's models are open source, allowing users and developers to access, review, and modify the model's source code under the terms of its license. A closed type indicates that the models are closed source, meaning the source code is proprietary, and access to the internal workings of the model is restricted to the provider. This classification helps users and administrators understand the level of transparency, flexibility, and control they have over the models integrated into the system. Type of model endpoint, this can be ",(0,i.jsx)(r.code,{children:"open"}),", ",(0,i.jsx)(r.code,{children:"closed"}),"."]})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"config",children:"Config"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Field"}),(0,i.jsx)(r.th,{children:"Description"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"api_base"})}),(0,i.jsxs)(r.td,{children:["The foundational URL where all API requests are directed. It acts as the root from which endpoint paths are extended. For example, if you're integrating with a weather data API, you might have a base URL like ",(0,i.jsx)(r.code,{children:"https://api.weather.com/v1"}),". This URL is crucial as it forms the starting point for all API calls, ensuring they are directed to the correct server and service."]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"api_type"})}),(0,i.jsx)(r.td,{children:"This field categorizes the API according to its protocol or design philosophy, such as REST, SOAP, GraphQL, etc. The type of API can influence how requests are made, the structure of the requests, and how responses are handled. Understanding the API type is essential for correctly utilizing its capabilities and for implementing the appropriate request and response handling mechanisms in your application."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"api_version"})}),(0,i.jsx)(r.td,{children:"APIs often evolve, leading to different versions that might introduce new features, improvements, or deprecations of old features. This field specifies the version of the API you're targeting, which is crucial for ensuring compatibility and understanding the specific functionalities available to you. API versions are often indicated in the URL path (e.g., /v1) but can also be specified in headers or request parameters."})]})]})]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},22707:(e,r,t)=>{t.d(r,{A:()=>w});var n=t(96540),i=t(18215),s=t(44319),o=t(56347),a=t(94280),l=t(73024),c=t(58417),d=t(44031);function u(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:r,children:t}=e;return(0,n.useMemo)((()=>{const e=r??function(e){return u(e).map((({props:{value:e,label:r,attributes:t,default:n}})=>({value:e,label:r,attributes:t,default:n})))}(t);return function(e){const r=(0,c.XI)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,t])}function p({value:e,tabValues:r}){return r.some((r=>r.value===e))}function f({queryString:e=!1,groupId:r}){const t=(0,o.W6)(),i=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,l.aZ)(i),(0,n.useCallback)((e=>{if(!i)return;const r=new URLSearchParams(t.location.search);r.set(i,e),t.replace({...t.location,search:r.toString()})}),[i,t])]}function v(e){const{defaultValue:r,queryString:t=!1,groupId:i}=e,s=h(e),[o,l]=(0,n.useState)((()=>function({defaultValue:e,tabValues:r}){if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=r.find((e=>e.default))??r[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:r,tabValues:s}))),[c,u]=f({queryString:t,groupId:i}),[v,m]=function({groupId:e}){const r=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,d.Dv)(r);return[t,(0,n.useCallback)((e=>{r&&i.set(e)}),[r,i])]}({groupId:i}),g=(()=>{const e=c??v;return p({value:e,tabValues:s})?e:null})();(0,a.A)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),m(e)}),[u,m,s]),tabValues:s}}var m=t(46916);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function j({className:e,block:r,selectedValue:t,selectValue:n,tabValues:o}){const a=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),c=e=>{const r=e.currentTarget,i=a.indexOf(r),s=o[i].value;s!==t&&(l(r),n(s))},d=e=>{let r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;r=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;r=a[t]??a[a.length-1];break}}r?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":r},e),children:o.map((({value:e,label:r,attributes:n})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{a.push(e)},onKeyDown:d,onClick:c,...n,className:(0,i.A)("tabs__item",g.tabItem,n?.className,{"tabs__item--active":t===e}),children:r??e},e)))})}function x({lazy:e,children:r,selectedValue:t}){const s=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){const e=s.find((e=>e.props.value===t));return e?(0,n.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map(((e,r)=>(0,n.cloneElement)(e,{key:r,hidden:e.props.value!==t})))})}function y(e){const r=v(e);return(0,b.jsxs)("div",{className:(0,i.A)("tabs-container",g.tabList),children:[(0,b.jsx)(j,{...r,...e}),(0,b.jsx)(x,{...r,...e})]})}function w(e){const r=(0,m.A)();return(0,b.jsx)(y,{...e,children:u(e.children)},String(r))}},53632:(e,r,t)=>{t.d(r,{A:()=>o});t(96540);var n=t(18215);const i={tabItem:"tabItem_Ymn6"};var s=t(74848);function o({children:e,hidden:r,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,n.A)(i.tabItem,t),hidden:r,children:e})}}}]);