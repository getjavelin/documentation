"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2966],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>m});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),g=o,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||a;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},3973:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var r=n(8168),o=(n(6540),n(5680));const a={},s="Custom Guardrails",i={unversionedId:"javelin-processors/custom",id:"javelin-processors/custom",title:"Custom Guardrails",description:"Javelin can be extended with custom guardrails to enable additional functionality. Custom guardrails can be used to perform custom operations on the input data before it is sent to the model or on the output data before it is returned to the user. Custom guardrails can also be used to implement custom data transformations, data validation, data augmentation, and more.",source:"@site/docs/javelin-processors/custom.md",sourceDirName:"javelin-processors",slug:"/javelin-processors/custom",permalink:"/docs/javelin-processors/custom",draft:!1,editUrl:"https://github.com/getjavelin/documentation/tree/main/docs/javelin-processors/custom.md",tags:[],version:"current",frontMatter:{},sidebar:"someSidebar",previous:{title:"Hallucination Detection",permalink:"/docs/javelin-processors/hallucination"},next:{title:"Quickstart Guide",permalink:"/docs/javelin-python/quickstart"}},l={},p=[{value:"Custom Processor Interface",id:"custom-processor-interface",level:2},{value:"Building a Custom Guardrail",id:"building-a-custom-guardrail",level:2},{value:"Golang",id:"golang",level:3},{value:"Step1: Install the dependencies",id:"step1-install-the-dependencies",level:4},{value:"Step2: Generate the stubs from the <code>.proto</code> file",id:"step2-generate-the-stubs-from-the-proto-file",level:4},{value:"Step 3: Implement the server",id:"step-3-implement-the-server",level:4},{value:"Python",id:"python",level:3},{value:"Step1: Install the dependencies",id:"step1-install-the-dependencies-1",level:4},{value:"Step2: Generate the stubs from the <code>.proto</code> file",id:"step2-generate-the-stubs-from-the-proto-file-1",level:4},{value:"Step3: Implement the server",id:"step3-implement-the-server",level:4},{value:"TypeScript",id:"typescript",level:3},{value:"Step1: Install the dependencies",id:"step1-install-the-dependencies-2",level:4},{value:"Step2: Generate the stubs from the <code>.proto</code> file",id:"step2-generate-the-stubs-from-the-proto-file-2",level:4},{value:"Step3: Implement the server",id:"step3-implement-the-server-1",level:4}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.yg)(u,(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"custom-guardrails"},"Custom Guardrails"),(0,o.yg)("p",null,"Javelin can be extended with custom guardrails to enable additional functionality. Custom guardrails can be used to perform custom operations on the input data before it is sent to the model or on the output data before it is returned to the user. Custom guardrails can also be used to implement custom data transformations, data validation, data augmentation, and more. "),(0,o.yg)("p",null,"Javelin executes a processor chain configured as a directed acyclic graph(DAG) of processors. Each processor in the chain is a self-contained module designed to perform a specific function. The processors are arranged in a sequence to facilitate complex processing sequences and ensure the execution flow is efficient, logical, and adaptable to various enterprise needs. "),(0,o.yg)("p",null,"There are 2 components to building custom guardrails in Javelin:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Extension Processor"),(0,o.yg)("li",{parentName:"ol"},"Custom Guardrail Service")),(0,o.yg)("p",null,"When incorporating custom guardrails, you will need to configure a special 'extension_processor' that will call the custom guardrail. The extension_processor is configured in Javelin's request or response chain to execute the custom guardrail and the GRPC endpoint for the custom guardrail is configured as input in the extension_processor configuration. "),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"Tip:")," Custom guardrail endpoints should be implemented as GRPC services and configured in javelin for low latency and high throughput.")),(0,o.yg)("p",null,"The extension_processor provides a convenient and flexible GRPC interface that allows you to implement custom guardrails in any language that supports GRPC. The extension_processor can be configured to call the custom guardrail service over GRPC."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"    +---------+\n    | Javelin |\n    +---------+\n        |\n        v\n    +---------------------------------+\n    | +-----------+     +-----------+ |\n    | | Processor | --\x3e | Processor | |\n    | +-----------+     +-----------+ |\n    |        |              |         |\n    |        v              v         |\n    |    +--------------------------+ |\n    |    |    Extension_Processor   | |\n    |    +--------------------------+ |\n    +---------------------------------+\n                     |\n                     | GRPC\n                     v\n        +--------------------------+\n        | Custom Guardrail Service |\n        +--------------------------+\n")),(0,o.yg)("h2",{id:"custom-processor-interface"},"Custom Processor Interface"),(0,o.yg)("p",null,"The GRPC interface consists of the following methods (.proto):"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-go"},'    // Sample interface (for most recent interface please refer to the latest .proto file)\n    syntax = "proto3";\n\n    package test_plugin;\n\n    // Specify the Go package where the generated files should reside\n    option go_package = "javelin-core/pkg/chainprocessor/processor-sdk/api";\n\n    // Define the Guardrail service\n    service Guardrail {\n        // Link the RPC method to the correct request and response message types\n        rpc Evaluate(GuardrailRequest) returns (GuardrailResponse) {}\n    }\n\n    // Enum for different content types\n    enum ContentType {\n        CONTENT_TYPE_UNSPECIFIED = 0;  // Default value if not specified\n        CONTENT_TYPE_JSON = 1;         // application/json\n        CONTENT_TYPE_RAW_TEXT = 2;     // text/plain\n        CONTENT_TYPE_EMBEDDINGS = 3;   // application/embeddings\n        CONTENT_TYPE_JPEG = 4;         // image/jpeg\n        CONTENT_TYPE_MP4 = 5;          // video/mp4\n    }\n\n    // GuardrailRequest message contains content type, payload, headers, config, \n    // and media data.\n    message GuardrailRequest {\n        // Type of the media (e.g., "text/json", "text/raw", "image/jpeg", "video/mp4")\n        ContentType content_type = 1;\n\n        // Dictionary of body entries\n        map<string, string> input_body = 2;\n\n        // Dictionary of configuration entries\n        map<string, string> config = 3;\n        \n        // Dictionary of header entries\n        map<string, string> headers = 4;\n\n        // Binary data for images or videos\n        bytes input_media = 5;\n    }\n\n    // GuardrailResponse message contains transformed content type, \n    // body, response metadata, instructions, and media data.\n    message GuardrailResponse {\n        // Dictionary of transformed body entries\n        map<string, string> transformed_body = 1;\n\n        // Dictionary of response metadata\n        map<string, string> response_metadata = 2;\n\n        // Dictionary of header entries\n        map<string, string> headers = 3;\n\n        // Transformed binary data for images or videos\n        bytes transformed_media = 4;\n    }\n\n')),(0,o.yg)("p",null,"Custom guardrails can be implemented in any language and are ideally expected to be hosted/deployed in the same cluster that is running Javelin for low latency access. The custom processor should implement the ",(0,o.yg)("inlineCode",{parentName:"p"},"Guardrail")," service defined in the ",(0,o.yg)("inlineCode",{parentName:"p"},".proto")," file. "),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"Evaluate")," method should take a ",(0,o.yg)("inlineCode",{parentName:"p"},"GuardrailRequest")," as input and return a ",(0,o.yg)("inlineCode",{parentName:"p"},"GuardrailResponse")," as output."),(0,o.yg)("h2",{id:"building-a-custom-guardrail"},"Building a Custom Guardrail"),(0,o.yg)("p",null,"You will first need to decide what language you plan to write your custom guardrail in. The custom guardrail can be written in any language that supports GRPC."),(0,o.yg)("h3",{id:"golang"},"Golang"),(0,o.yg)("p",null,"To build a custom guardrail in Golang, you will need to install the following dependencies:"),(0,o.yg)("h4",{id:"step1-install-the-dependencies"},"Step1: Install the dependencies"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n    go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n")),(0,o.yg)("h4",{id:"step2-generate-the-stubs-from-the-proto-file"},"Step2: Generate the stubs from the ",(0,o.yg)("inlineCode",{parentName:"h4"},".proto")," file"),(0,o.yg)("p",null,"Next, you will need to generate the Golang code from the ",(0,o.yg)("inlineCode",{parentName:"p"},".proto")," file. You can use the following command to generate the Golang code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    protoc --go_out=. --go-grpc_out=. javelin_custom_guardrails.proto\n")),(0,o.yg)("h4",{id:"step-3-implement-the-server"},"Step 3: Implement the server"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-go"},'    package main\n\n    import (\n        "context"\n        "log"\n        "net"\n\n        "google.golang.org/grpc"\n        pb "path/to/your/generated/package" // Use the correct package path\n    )\n\n    type server struct {\n        pb.UnimplementedGuardrailServer\n    }\n\n    func (s *server) Evaluate(ctx context.Context, in *pb.GuardrailRequest) (*pb.GuardrailResponse, error) {\n        response := &pb.GuardrailResponse{\n            TransformedBody: map[string]string{"message": "Processed: " + in.GetInputBody()["data"]},\n        }\n        return response, nil\n    }\n\n    func main() {\n        lis, err := net.Listen("tcp", ":50051")\n        if err != nil {\n            log.Fatalf("failed to listen: %v", err)\n        }\n        s := grpc.NewServer()\n        pb.RegisterGuardrailServer(s, &server{})\n        log.Printf("Server listening at %v", lis.Addr())\n        if err := s.Serve(lis); err != nil {\n            log.Fatalf("failed to serve: %v", err)\n        }\n    }\n')),(0,o.yg)("h3",{id:"python"},"Python"),(0,o.yg)("p",null,"To build a custom guardrail in Python, you will need to install the following dependencies:"),(0,o.yg)("h4",{id:"step1-install-the-dependencies-1"},"Step1: Install the dependencies"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    pip install grpcio grpcio-tools\n")),(0,o.yg)("h4",{id:"step2-generate-the-stubs-from-the-proto-file-1"},"Step2: Generate the stubs from the ",(0,o.yg)("inlineCode",{parentName:"h4"},".proto")," file"),(0,o.yg)("p",null,"Next, you will need to generate the Python code from the ",(0,o.yg)("inlineCode",{parentName:"p"},".proto")," file. You can use the following command to generate the Python code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. test_guardrail.proto\n")),(0,o.yg)("h4",{id:"step3-implement-the-server"},"Step3: Implement the server"),(0,o.yg)("p",null,"Sample python grpc guardrail server:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'    import grpc\n    from concurrent import futures\n    import time\n    import test_guardrail_pb2\n    import test_guardrail_pb2_grpc\n\n    class GuardrailServicer(test_guardrail_pb2_grpc.GuardrailServicer):\n        def Evaluate(self, request, context):\n            print("Received request: ", request)\n            response = test_guardrail_pb2.GuardrailResponse()\n            response.transformed_body["output"] = "Hello from Python"\n            return response\n\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    test_guardrail_pb2_grpc.add_GuardrailServicer_to_server(GuardrailServicer(), server)\n    server.add_insecure_port(\'[::]:50051\')\n    server.start()\n    print("Server started")\n    try:\n        while True:\n            time.sleep(86400)\n    except KeyboardInterrupt:\n        server.stop(0)\n')),(0,o.yg)("h3",{id:"typescript"},"TypeScript"),(0,o.yg)("p",null,"To build a custom guardrail in TypeScript, you will need to install the following dependencies:"),(0,o.yg)("h4",{id:"step1-install-the-dependencies-2"},"Step1: Install the dependencies"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    npm install @grpc/grpc-js @grpc/proto-loader\n")),(0,o.yg)("h4",{id:"step2-generate-the-stubs-from-the-proto-file-2"},"Step2: Generate the stubs from the ",(0,o.yg)("inlineCode",{parentName:"h4"},".proto")," file"),(0,o.yg)("p",null,"Next, you will need to generate the TypeScript code from the ",(0,o.yg)("inlineCode",{parentName:"p"},".proto")," file. You can use the following command to generate the\nTypeScript code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"    npm install -g grpc-tools\n    grpc_tools_node_protoc --js_out=import_style=commonjs,binary:./output \\\n        --grpc_out=grpc_js:./output \\\n        --ts_out=grpc_js:./output \\\n        -I ./proto path/to/your/file.proto\n")),(0,o.yg)("h4",{id:"step3-implement-the-server-1"},"Step3: Implement the server"),(0,o.yg)("p",null,"Sample TypeScript grpc guardrail server:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"    import * as grpc from '@grpc/grpc-js';\n    import * as protoLoader from '@grpc/proto-loader';\n    import { ProtoGrpcType } from './proto/test_plugin'; // Adjust the import according to your generated file\n\n    const packageDefinition = protoLoader.loadSync('path/to/your/file.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true\n    });\n\n    const protoDescriptor = grpc.loadPackageDefinition(packageDefinition) as unknown as ProtoGrpcType;\n    const testPlugin = protoDescriptor.test_plugin;\n\n    function evaluate(call: grpc.ServerUnaryCall<pb.GuardrailRequest, pb.GuardrailResponse>, callback: grpc.sendUnaryData<pb.GuardrailResponse>) {\n        const response: pb.GuardrailResponse = {\n            transformedBody: { message: 'Processed: ' + call.request.inputBody['data'] }\n        };\n        callback(null, response);\n    }\n\n    function getServer() {\n        const server = new grpc.Server();\n        server.addService(testPlugin.Guardrail.service, { evaluate: evaluate });\n        return server;\n    }\n\n    const server = getServer();\n    server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), (err, port) => {\n        if (err) {\n            console.error(`Server error: ${err.message}`);\n        } else {\n            console.log(`Server listening on ${port}`);\n            server.start();\n        }\n    });\n")))}d.isMDXComponent=!0}}]);